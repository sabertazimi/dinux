[global idt_flush]
idt_flush:
    mov     eax, [esp + 4]
    lidt    [eax]
    ret
.end:

%macro ISR_NOERRCODE 1
[global isr%1]
isr%1:
    cli
    push $0      ; invalid err code, simplify handler logic
    push %1     ; int_no
    jmp isr_common_stub
%endmacro

%macro ISR_ERRCODE 1
[global isr%1]
isr%1:
    cli
    push %1     ; int_no
    jmp isr_common_stub
%endmacro

; interrupt service routine
ISR_NOERRCODE   0
ISR_NOERRCODE   1
ISR_NOERRCODE   2
ISR_NOERRCODE   3
ISR_NOERRCODE   4
ISR_NOERRCODE   5
ISR_NOERRCODE   6
ISR_NOERRCODE   7
; FIX ME
ISR_ERRCODE     8
ISR_NOERRCODE   9
; FIX ME
; push 0 push %1
ISR_ERRCODE     10
ISR_ERRCODE     11
ISR_ERRCODE     12
ISR_ERRCODE     13
ISR_ERRCODE     14
ISR_NOERRCODE   15
ISR_NOERRCODE   16
ISR_ERRCODE     17
ISR_NOERRCODE   18
ISR_NOERRCODE   19

ISR_NOERRCODE   20
ISR_NOERRCODE   21
ISR_NOERRCODE   22
ISR_NOERRCODE   23
ISR_NOERRCODE   24
ISR_NOERRCODE   25
ISR_NOERRCODE   26
ISR_NOERRCODE   27
ISR_NOERRCODE   28
ISR_NOERRCODE   29
ISR_NOERRCODE   30
ISR_NOERRCODE   31

ISR_NOERRCODE   255

[global isr_common_stub]
[extern isr_handler]
isr_common_stub:
    pusha           ; push edi, esi, ebp, esp, ebx, edx, ecx, eax
    push ds
    push es
    push fs
    push gs

    mov ax, 0x10    ; load kernel data segment descriptor
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax

    mov eax, esp
    push eax        ; push (pt_regs *)
    call isr_handler
    pop eax         ; clear pushed argument(pt_regs *)

    pop gs
    pop fs
    pop es
    pop ds
    popa            ; pop edi, esi, ebp, esp, ebx, edx, ecx, eax

    add esp, 8
    iret
.end:
